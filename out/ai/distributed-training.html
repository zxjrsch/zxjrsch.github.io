<!DOCTYPE html><!--3WqXp_18PFG2QAibL4Ptl--><html lang="en"><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1"/><link rel="preload" href="/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="preload" href="/_next/static/media/caa3a2e1cccd8315-s.p.853070df.woff2" as="font" crossorigin="" type="font/woff2"/><link rel="stylesheet" href="/_next/static/chunks/1fcb9d377ba4db76.css" data-precedence="next"/><link rel="stylesheet" href="/_next/static/chunks/4057cc9dbcc744c0.css" data-precedence="next"/><link rel="preload" as="script" fetchPriority="low" href="/_next/static/chunks/be439e04947a2cba.js"/><script src="/_next/static/chunks/922a6be1c048f7e7.js" async=""></script><script src="/_next/static/chunks/748df87cf5306c08.js" async=""></script><script src="/_next/static/chunks/turbopack-0af7db035ef23dbc.js" async=""></script><script src="/_next/static/chunks/988ea292de4c4c73.js" async=""></script><script src="/_next/static/chunks/7a959126392b4956.js" async=""></script><script src="/_next/static/chunks/3020cc836eb789f8.js" async=""></script><script src="/_next/static/chunks/e5d291186d0cbb54.js" async=""></script><script src="/_next/static/chunks/bc166ea53d390db7.js" async=""></script><meta name="next-size-adjust" content=""/><title>Claire Zhao Blog</title><meta name="description" content="Claire Zhao&#x27;s Blog on AI and Math"/><link rel="icon" href="/favicon.ico?favicon.e10ff5c7.ico" sizes="1176x1032" type="image/x-icon"/><script src="/_next/static/chunks/a6dad97d9634a72d.js" noModule=""></script></head><body class="geist_a71539c9-module__T19VSG__variable geist_mono_8d43a2aa-module__8Li5zG__variable antialiased"><div hidden=""><!--$--><!--/$--></div><div class="flex flex-col justify-center min-h-screen"><div class="flex flex-row justify-center pt-15"><div class="flex flex-row w-full md:max-w-5/10 relative"><div class="flex flex-row md:basis-1/3 "><a href="/"><div class="text-2xl font-bold pl-5 md:pl-0 pt-5 md:pt-0">Claire Zhao</div></a></div><div class="md:hidden grow flex justify-end items-center pr-10"><button><svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg" class="size-5"><path d="M8 2H13.5C13.7761 2 14 2.22386 14 2.5V12.5C14 12.7761 13.7761 13 13.5 13H8V2ZM7 2H1.5C1.22386 2 1 2.22386 1 2.5V12.5C1 12.7761 1.22386 13 1.5 13H7V2ZM0 2.5C0 1.67157 0.671573 1 1.5 1H13.5C14.3284 1 15 1.67157 15 2.5V12.5C15 13.3284 14.3284 14 13.5 14H1.5C0.671573 14 0 13.3284 0 12.5V2.5Z" fill="currentColor" fill-rule="evenodd" clip-rule="evenodd"></path></svg></button></div><nav class="hidden md:flex basis-2/3 flex-row justify-end gap-x-8"><a href="/ai"><div class="flex items-center gap-2 font-medium hover:underline">Machine Learning <svg width="15" height="15" viewBox="0 0 15 15" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M9 4L9 11L4.5 7.5L9 4Z" fill="currentColor"></path></svg></div></a><a href="/math"><div class="flex items-center gap-2 font-medium hover:underline">Mathematics </div></a></nav></div></div><div class="grow flex justify-center w-full pt-10 md:pt-15 px-3"><div class="flex flex-col w-full max-w-full md:max-w-2xl lg:max-w-3xl"><div class="text-3xl font-bold flex justify-center">6D Parallelism for Distributed Training</div><div class="text-sm flex justify-center pt-5"></div><div class=""><div><div class="indent-10 md:mt-10 grow text-lg font-medium text-base text-justify"><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">Matrix multiplication is a fundamental operator in neural networks, and in the previous <a class="
    underline decoration-sky-500
    underline-offset-4
    " target="_blank" rel="noopener noreferrer" href="/ai/distributed-training">blog</a> we have fully elucidated the differentiation of the loss through such an operator in full generality, and we have applied this to the attention operator, a compound operator consisting of a series of matrix mulitiplications. Let us assemble a clear view of the process of training a neural network. In particular let us examine the data being stored and their persistence.</div><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">Neural network weights is the first pieces of data that needs to be stored for the duration of training, it is used during forward pass to compute activation, and it is used during backwards pass to compute activation gradients. The second piece of data which require storage are the activation of each layers, since these are used to compute the  gradient of weights in the layer to which the activations are the inputs during forward pass, as we have already seen. Activation can be released whenever the weight gradients they are associated with are computed. The third piece of data that is stored are activation gradients. They are used to compute gradients during backpropagation through the next layer (or operation), and can be released after computing activation and weight gradients in the next layer (or operation). The fourth piece of data are weight gradients, with a lifetime from produced until the corresponding weights are updated. The fifth type of data are associated with the optimization algorithm which updates the weight using the gradients. In the Adam optimizer, we need to keep track of the exponential moving average of the weight and the square of each weight. These moving averages are ususally called optimizer states, and persist throughout training.</div><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">The effective management of the persistence and distribution (across GPUS and CPUs) is a core systems optimization problem.</div></div></div><div><div class=" pt-20 font-bold text-2xl" id="section-2">Distributed Data Parallel</div><div class="indent-10 md:mt-10 grow text-lg font-medium text-base text-justify"><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">We replicate a set of model weights identically across <span class="mt-10"></span> GPUs. Each GPU holds a distinct collection of training data. Each GPU passes forward with the data to compute the loss, and performs backward pass to compute the gradient. The gradient is <span class="font-semibold">all reduced</span> over <span class="mt-10"></span> parallel agents, and scaled by <span class="mt-10"></span> to obtain the average gradient. Each local parallel agent now holds identical copies of the global gradient. This gradient produces identical optimizer states across <span class="mt-10"></span> parallel agents. The optimizer have identical gradients, identical optimizer states, produces identical updated model weights across <span class="mt-10"></span> GPUs. The procedure is repeated.</div></div></div><div><div class=" pt-20 font-bold text-2xl" id="section-2">Fully Sharded Data Parallel</div><div class="indent-10 md:mt-10 grow text-lg font-medium text-base text-justify"><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">Suppose a neural network consists of <span class="mt-10"></span> layers <span class="mt-10"></span> whereby each layer is a function with suitable domain and range. The neural network evaluated on <span class="mt-10"></span> leading to loss <span class="mt-10"></span>, is defined by <span class="mt-10"></span> Let us introduce the notation that <span class="mt-10"></span> is a function parameterized by weight <span class="mt-10"></span> and takes as input the previous layer&#x27;s activation <span class="mt-10"></span>.</div><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">Given dataset <span class="mt-10"></span>, weight matrices <span class="mt-10"></span> and <span class="mt-10"></span> parallel agents (GPU, TPU etc) we partition the dataset into <span class="mt-10"></span> pariwise disjoint subsets <span class="mt-10"></span> and partition each weight matrix into N slices, for example <span class="mt-10"></span> To the <span class="mt-10"></span>-th parallel agent we send <span class="mt-10"></span></div><div class="indent-10 md:mt-5 grow text-lg font-medium text-base text-justify">To describe one step in training, each of the parallel agents <span class="mt-10"></span> selects a training data <span class="mt-10"></span> and puts <span class="mt-10"></span>. For <span class="mt-10"></span> suppose the activation <span class="mt-10"></span> has been computed and the forward pass is ready to advance through layer <span class="mt-10"></span> on parallel agent <span class="mt-10"></span> we call <span class="mt-10"></span> and compute <span class="mt-10"></span> and immediately free the memory on device <span class="mt-10"></span> of the weight shards <span class="mt-10"></span> and store the layer-<span class="mt-10"></span> activation for weight gradient calculation through <span class="mt-10"></span> during backward pass <span class="mt-10"></span> Let us turn to backwards pass. In our notation <span class="mt-10"></span> computes the loss function and this layer has no weights, so as backwards we get <span class="mt-10"></span>just as reminder <span class="mt-10"></span> is the output of layer <span class="mt-10"></span>, which is the input to layer <span class="mt-10"></span>. We will treat <span class="mt-10"></span> as a variable, whereas the actual activation has a superscript <span class="mt-10"></span> to identify the device <span class="mt-10"></span>. For each <span class="mt-10"></span> supposed that device <span class="mt-10"></span> computed its local activation gradient <span class="mt-10"></span> have computed. Then the local weight gradient can be computed as a function <span class="mt-10"></span> of the map <span class="mt-10"></span>, the activation gradient, and the local activation <span class="mt-10"></span> Since weights are kept in shards across the parallel agents, we need to partition the weight gradient too <span class="mt-10"></span> we will use <span class="font-semibold">ReduceScatter</span> to provide each parallel agent with the average gradient corresponding to the weight shard it owns, namely it receives <span class="mt-10"></span> scaling by <span class="mt-10"></span> this is the average gradient for its local weight shard <span class="mt-10"></span>. The local Adam optimizer stores exponential moving averages of <span class="mt-10"></span> and the component-wise square of <span class="mt-10"></span>. Thus optimizer states are sharded as well. Finally each parallel agent <span class="mt-10"></span> needs to compute its local activation gradient as a function <span class="mt-10"></span> of the function <span class="mt-10"></span> (that we will differentiate via the chain rule) and the weight <span class="mt-10"></span> of layer <span class="mt-10"></span> together with <span class="mt-10"></span> namely <span class="mt-10"></span> Computing this allows  backpropagation to advance from layer <span class="mt-10"></span> to layer <span class="mt-10"></span>. To do this we need to AllGather the weight <span class="mt-10"></span> on each of the parallel agents  <span class="mt-10"></span> After computing the activaiton gradient <span class="mt-10"></span></div></div></div></div></div></div><div class="flex justify-center my-5 md:my-10">Claire Zhao Â© 2026</div></div><!--$--><!--/$--><script src="/_next/static/chunks/be439e04947a2cba.js" id="_R_" async=""></script><script>(self.__next_f=self.__next_f||[]).push([0])</script><script>self.__next_f.push([1,"1:\"$Sreact.fragment\"\n2:I[48523,[\"/_next/static/chunks/988ea292de4c4c73.js\",\"/_next/static/chunks/7a959126392b4956.js\"],\"default\"]\n3:I[82281,[\"/_next/static/chunks/988ea292de4c4c73.js\",\"/_next/static/chunks/7a959126392b4956.js\"],\"default\"]\n4:I[1565,[\"/_next/static/chunks/3020cc836eb789f8.js\",\"/_next/static/chunks/e5d291186d0cbb54.js\",\"/_next/static/chunks/bc166ea53d390db7.js\"],\"default\"]\n5:I[6366,[\"/_next/static/chunks/3020cc836eb789f8.js\",\"/_next/static/chunks/e5d291186d0cbb54.js\",\"/_next/static/chunks/bc166ea53d390db7.js\"],\"default\"]\n10:I[75067,[],\"default\"]\n:HL[\"/_next/static/chunks/1fcb9d377ba4db76.css\",\"style\"]\n:HL[\"/_next/static/chunks/4057cc9dbcc744c0.css\",\"style\"]\n:HL[\"/_next/static/media/797e433ab948586e-s.p.dbea232f.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n:HL[\"/_next/static/media/caa3a2e1cccd8315-s.p.853070df.woff2\",\"font\",{\"crossOrigin\":\"\",\"type\":\"font/woff2\"}]\n6:T501,Neural network weights is the first pieces of data that needs to be stored for the duration of training, it is used during forward pass to compute activation, and it is used during backwards pass to compute activation gradients. The second piece of data which require storage are the activation of each layers, since these are used to compute the  gradient of weights in the layer to which the activations are the inputs during forward pass, as we have already seen. Activation can be released whenever the weight gradients they are associated with are computed. The third piece of data that is stored are activation gradients. They are used to compute gradients during backpropagation through the next layer (or operation), and can be released after computing activation and weight gradients in the next layer (or operation). The fourth piece of data are weight gradients, with a lifetime from produced until the corresponding weights are updated. The fifth type of data are associated with the optimization algorithm which updates the weight using the gradients. In the Adam optimizer, we need to keep track of the exponential moving average of the weight and the square of each weight. These moving averages are ususally called optimizer states, and persist throughout training."])</script><script>self.__next_f.push([1,"0:{\"P\":null,\"b\":\"3WqXp_18PFG2QAibL4Ptl\",\"c\":[\"\",\"ai\",\"distributed-training\"],\"q\":\"\",\"i\":false,\"f\":[[[\"\",{\"children\":[\"ai\",{\"children\":[\"distributed-training\",{\"children\":[\"__PAGE__\",{}]}]}]},\"$undefined\",\"$undefined\",true],[[\"$\",\"$1\",\"c\",{\"children\":[[[\"$\",\"link\",\"0\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/1fcb9d377ba4db76.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}],[\"$\",\"link\",\"1\",{\"rel\":\"stylesheet\",\"href\":\"/_next/static/chunks/4057cc9dbcc744c0.css\",\"precedence\":\"next\",\"crossOrigin\":\"$undefined\",\"nonce\":\"$undefined\"}]],[\"$\",\"html\",null,{\"lang\":\"en\",\"children\":[\"$\",\"body\",null,{\"className\":\"geist_a71539c9-module__T19VSG__variable geist_mono_8d43a2aa-module__8Li5zG__variable antialiased\",\"children\":[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":[[[\"$\",\"title\",null,{\"children\":\"404: This page could not be found.\"}],[\"$\",\"div\",null,{\"style\":{\"fontFamily\":\"system-ui,\\\"Segoe UI\\\",Roboto,Helvetica,Arial,sans-serif,\\\"Apple Color Emoji\\\",\\\"Segoe UI Emoji\\\"\",\"height\":\"100vh\",\"textAlign\":\"center\",\"display\":\"flex\",\"flexDirection\":\"column\",\"alignItems\":\"center\",\"justifyContent\":\"center\"},\"children\":[\"$\",\"div\",null,{\"children\":[[\"$\",\"style\",null,{\"dangerouslySetInnerHTML\":{\"__html\":\"body{color:#000;background:#fff;margin:0}.next-error-h1{border-right:1px solid rgba(0,0,0,.3)}@media (prefers-color-scheme:dark){body{color:#fff;background:#000}.next-error-h1{border-right:1px solid rgba(255,255,255,.3)}}\"}}],[\"$\",\"h1\",null,{\"className\":\"next-error-h1\",\"style\":{\"display\":\"inline-block\",\"margin\":\"0 20px 0 0\",\"padding\":\"0 23px 0 0\",\"fontSize\":24,\"fontWeight\":500,\"verticalAlign\":\"top\",\"lineHeight\":\"49px\"},\"children\":404}],[\"$\",\"div\",null,{\"style\":{\"display\":\"inline-block\"},\"children\":[\"$\",\"h2\",null,{\"style\":{\"fontSize\":14,\"fontWeight\":400,\"lineHeight\":\"49px\",\"margin\":0},\"children\":\"This page could not be found.\"}]}]]}]}]],[]],\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]}]}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[null,[\"$\",\"$L2\",null,{\"parallelRouterKey\":\"children\",\"error\":\"$undefined\",\"errorStyles\":\"$undefined\",\"errorScripts\":\"$undefined\",\"template\":[\"$\",\"$L3\",null,{}],\"templateStyles\":\"$undefined\",\"templateScripts\":\"$undefined\",\"notFound\":\"$undefined\",\"forbidden\":\"$undefined\",\"unauthorized\":\"$undefined\"}]]}],{\"children\":[[\"$\",\"$1\",\"c\",{\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-col justify-center min-h-screen\",\"children\":[[\"$\",\"div\",null,{\"className\":\"flex flex-row justify-center pt-15\",\"children\":[\"$\",\"$L4\",null,{}]}],[\"$\",\"div\",null,{\"className\":\"grow flex justify-center w-full pt-10 md:pt-15 px-3\",\"children\":[\"$\",\"div\",null,{\"className\":\"flex flex-col w-full max-w-full md:max-w-2xl lg:max-w-3xl\",\"children\":[[\"$\",\"div\",null,{\"className\":\"text-3xl font-bold flex justify-center\",\"children\":\"6D Parallelism for Distributed Training\"}],[\"$\",\"div\",null,{\"className\":\"text-sm flex justify-center pt-5\",\"children\":null}],[\"$\",\"div\",null,{\"className\":\"\",\"children\":[[\"$\",\"div\",\"0\",{\"children\":[\"$undefined\",[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-10 grow text-lg font-medium text-base text-justify\",\"children\":[[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":[\"Matrix multiplication is a fundamental operator in neural networks, and in the previous \",[\"$\",\"$L5\",null,{\"text\":\"blog\",\"url\":\"/ai/distributed-training\"}],\" we have fully elucidated the differentiation of the loss through such an operator in full generality, and we have applied this to the attention operator, a compound operator consisting of a series of matrix mulitiplications. Let us assemble a clear view of the process of training a neural network. In particular let us examine the data being stored and their persistence.\"]}],[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":\"$6\"}],\"$L7\"]}]]}],\"$L8\",\"$L9\"]}]]}]}],\"$La\"]}],[\"$Lb\",\"$Lc\",\"$Ld\"],\"$Le\"]}],{},null,false,false]},null,false,false]},null,false,false]},null,false,false],\"$Lf\",false]],\"m\":\"$undefined\",\"G\":[\"$10\",[]],\"S\":true}\n"])</script><script>self.__next_f.push([1,"11:I[96045,[\"/_next/static/chunks/3020cc836eb789f8.js\",\"/_next/static/chunks/e5d291186d0cbb54.js\",\"/_next/static/chunks/bc166ea53d390db7.js\"],\"default\"]\n2f:I[56691,[\"/_next/static/chunks/3020cc836eb789f8.js\",\"/_next/static/chunks/e5d291186d0cbb54.js\",\"/_next/static/chunks/bc166ea53d390db7.js\"],\"default\"]\n30:I[47259,[\"/_next/static/chunks/988ea292de4c4c73.js\",\"/_next/static/chunks/7a959126392b4956.js\"],\"OutletBoundary\"]\n31:\"$Sreact.suspense\"\n33:I[47259,[\"/_next/static/chunks/988ea292de4c4c73.js\",\"/_next/static/chunks/7a959126392b4956.js\"],\"ViewportBoundary\"]\n35:I[47259,[\"/_next/static/chunks/988ea292de4c4c73.js\",\"/_next/static/chunks/7a959126392b4956.js\"],\"MetadataBoundary\"]\n7:[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":\"The effective management of the persistence and distribution (across GPUS and CPUs) is a core systems optimization problem.\"}]\n8:[\"$\",\"div\",\"1\",{\"children\":[[\"$\",\"div\",null,{\"className\":\" pt-20 font-bold text-2xl\",\"id\":\"section-2\",\"children\":\"Distributed Data Parallel\"}],[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-10 grow text-lg font-medium text-base text-justify\",\"children\":[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":[\"We replicate a set of model weights identically across \",[\"$\",\"$L11\",null,{\"latex\":\"N\",\"className\":\"mt-10\"}],\" GPUs. Each GPU holds a distinct collection of training data. Each GPU passes forward with the data to compute the loss, and performs backward pass to compute the gradient. The gradient is \",[\"$\",\"span\",null,{\"className\":\"font-semibold\",\"children\":\"all reduced\"}],\" over \",[\"$\",\"$L11\",null,{\"latex\":\"N\",\"className\":\"mt-10\"}],\" parallel agents, and scaled by \",[\"$\",\"$L11\",null,{\"latex\":\"N^{-1}\",\"className\":\"mt-10\"}],\" to obtain the average gradient. Each local parallel agent now holds identical copies of the global gradient. This gradient produces identical optimizer states across \",[\"$\",\"$L11\",null,{\"latex\":\"N\",\"className\":\"mt-10\"}],\" parallel agents. The optimizer have identical gradients, identical optimizer states, produces identical updated model weights across \",[\"$\",\"$L11\",null,{\"latex\":\"N\",\"className\":\"mt-10\"}],\" GPUs. The procedure is repeated.\"]}]}]]}]\n"])</script><script>self.__next_f.push([1,"9:[\"$\",\"div\",\"2\",{\"children\":[[\"$\",\"div\",null,{\"className\":\" pt-20 font-bold text-2xl\",\"id\":\"section-2\",\"children\":\"Fully Sharded Data Parallel\"}],[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-10 grow text-lg font-medium text-base text-justify\",\"children\":[[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":[\"Suppose a neural network consists of \",[\"$\",\"$L11\",null,{\"latex\":\"K\",\"className\":\"mt-10\"}],\" layers \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\{L_i\\\\}_{i=1}^K\",\"className\":\"mt-10\"}],\" whereby each layer is a function with suitable domain and range. The neural network evaluated on \",[\"$\",\"$L11\",null,{\"latex\":\"x\",\"className\":\"mt-10\"}],\" leading to loss \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\ell(x)\",\"className\":\"mt-10\"}],\", is defined by \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\ell (x) = \\\\left(L_K\\\\circ \\\\dots \\\\circ L_1 \\\\right)(x)\",\"displayMode\":true,\"className\":\"mt-10\"}],\" Let us introduce the notation that \",[\"$\",\"$L11\",null,{\"latex\":\"L_i\",\"className\":\"mt-10\"}],\" is a function parameterized by weight \",[\"$\",\"$L11\",null,{\"latex\":\"W_i\",\"className\":\"mt-10\"}],\" and takes as input the previous layer's activation \",[\"$\",\"$L11\",null,{\"latex\":\"y_{i-1} = \\\\left(L_{i-1}\\\\circ \\\\dots \\\\circ L_1 \\\\right)(x)\",\"className\":\"mt-10\"}],\".\"]}],[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":[\"Given dataset \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\mathcal{D}\",\"className\":\"mt-10\"}],\", weight matrices \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\{W_i\\\\}_{i=1}^K\",\"className\":\"mt-10\"}],\" and \",[\"$\",\"$L11\",null,{\"latex\":\"N\",\"className\":\"mt-10\"}],\" parallel agents (GPU, TPU etc) we partition the dataset into \",[\"$\",\"$L11\",null,{\"latex\":\"N\",\"className\":\"mt-10\"}],\" pariwise disjoint subsets \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\mathcal{D} = \\\\mathcal{D}^{(1)}\\\\,\\\\cup \\\\dots \\\\cup \\\\mathcal{D}^{(N)}\",\"className\":\"mt-10\"}],\" and partition each weight matrix into N slices, for example \",[\"$\",\"$L11\",null,{\"latex\":\"W_i = [W_i^{(1)}| \\\\dots | W_i^{(N)}]\",\"displayMode\":true,\"className\":\"mt-10\"}],\" To the \",[\"$\",\"$L11\",null,{\"latex\":\"j\",\"className\":\"mt-10\"}],\"-th parallel agent we send \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\left(\\\\mathcal{D}^{(j)}, \\\\, W_1^{(j)}, \\\\dots, W_K^{(j)}\\\\right)\",\"className\":\"mt-10\"}]]}],[\"$\",\"div\",null,{\"className\":\"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify\",\"children\":[\"To describe one step in training, each of the parallel agents \",[\"$\",\"$L11\",null,{\"latex\":\"1\\\\leq j \\\\leq N\",\"className\":\"mt-10\"}],\" selects a training data \",[\"$\",\"$L11\",null,{\"latex\":\"x^{(j)}\\\\in \\\\mathcal{D}^{(j)}\",\"className\":\"mt-10\"}],\" and puts \",[\"$\",\"$L11\",null,{\"latex\":\"y_0^{(j)}=x^{(j)}\",\"className\":\"mt-10\"}],\". For \",[\"$\",\"$L11\",null,{\"latex\":\"1\\\\leq i \\\\leq K\",\"className\":\"mt-10\"}],\" suppose the activation \",[\"$\",\"$L11\",null,{\"latex\":\"y_{i-1}^{(j)}\",\"className\":\"mt-10\"}],\" has been computed and the forward pass is ready to advance through layer \",[\"$\",\"$L11\",null,{\"latex\":\"L_i\",\"className\":\"mt-10\"}],\" on parallel agent \",[\"$\",\"$L11\",null,{\"latex\":\"j\",\"className\":\"mt-10\"}],\" we call \",[\"$\",\"$L11\",null,{\"latex\":\"W_i = \\\\textbf{AllGather}\\\\left\\\\{W_i^{(j)}: 1\\\\leq j \\\\leq N\\\\right\\\\}\",\"displayMode\":true,\"className\":\"mt-10\"}],\" and compute \",[\"$\",\"$L11\",null,{\"latex\":\"y^{(j)}_i=L_i(y^{(j)}_{i-1})\",\"className\":\"mt-10\"}],\" and immediately free the memory on device \",[\"$\",\"$L11\",null,{\"latex\":\"j\",\"className\":\"mt-10\"}],\" of the weight shards \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\textbf{delete}\\\\left\\\\{W_i^{(k)}\\\\in W_i: j\\\\neq k\\\\right\\\\}\\\\quad (\\\\text{device}\\\\,j)\",\"displayMode\":true,\"className\":\"mt-10\"}],\" and store the layer-\",[\"$\",\"$L11\",null,{\"latex\":\"i\",\"className\":\"mt-10\"}],\" activation for weight gradient calculation through \",[\"$\",\"$L11\",null,{\"latex\":\"L_i\",\"className\":\"mt-10\"}],\" during backward pass \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\textbf{store}\\\\,\\\\, y_i^{(j)}\\\\quad(\\\\text{device } j)\",\"displayMode\":true,\"className\":\"mt-10\"}],\" Let us turn to backwards pass. In our notation \",[\"$\",\"$L11\",null,{\"latex\":\"L_K\",\"className\":\"mt-10\"}],\" computes the loss function and this layer has no weights, so as backwards we get \",[\"$\",\"$L11\",null,{\"latex\":\"\\\\frac{\\\\partial \\\\ell}{\\\\partial y_{K-1}}\",\"displayMode\":true,\"className\":\"mt-10\"}],\"just as reminder \",[\"$\",\"$L11\",null,{\"latex\":\"y_{K-1}\",\"className\":\"mt-10\"}],\" is the output of layer \",[\"$\",\"$L11\",null,{\"latex\":\"K-1\",\"className\":\"mt-10\"}],\", which is the input to layer \",\"$L12\",\". We will treat \",\"$L13\",\" as a variable, whereas the actual activation has a superscript \",\"$L14\",\" to identify the device \",\"$L15\",\". For each \",\"$L16\",\" supposed that device \",\"$L17\",\" computed its local activation gradient \",\"$L18\",\" have computed. Then the local weight gradient can be computed as a function \",\"$L19\",\" of the map \",\"$L1a\",\", the activation gradient, and the local activation \",\"$L1b\",\" Since weights are kept in shards across the parallel agents, we need to partition the weight gradient too \",\"$L1c\",\" we will use \",\"$L1d\",\" to provide each parallel agent with the average gradient corresponding to the weight shard it owns, namely it receives \",\"$L1e\",\" scaling by \",\"$L1f\",\" this is the average gradient for its local weight shard \",\"$L20\",\". The local Adam optimizer stores exponential moving averages of \",\"$L21\",\" and the component-wise square of \",\"$L22\",\". Thus optimizer states are sharded as well. Finally each parallel agent \",\"$L23\",\" needs to compute its local activation gradient as a function \",\"$L24\",\" of the function \",\"$L25\",\" (that we will differentiate via the chain rule) and the weight \",\"$L26\",\" of layer \",\"$L27\",\" together with \",\"$L28\",\" namely \",\"$L29\",\" Computing this allows  backpropagation to advance from layer \",\"$L2a\",\" to layer \",\"$L2b\",\". To do this we need to AllGather the weight \",\"$L2c\",\" on each of the parallel agents  \",\"$L2d\",\" After computing the activaiton gradient \",\"$L2e\"]}]]}]]}]\n"])</script><script>self.__next_f.push([1,"a:[\"$\",\"$L2f\",null,{}]\nb:[\"$\",\"script\",\"script-0\",{\"src\":\"/_next/static/chunks/3020cc836eb789f8.js\",\"async\":true,\"nonce\":\"$undefined\"}]\nc:[\"$\",\"script\",\"script-1\",{\"src\":\"/_next/static/chunks/e5d291186d0cbb54.js\",\"async\":true,\"nonce\":\"$undefined\"}]\nd:[\"$\",\"script\",\"script-2\",{\"src\":\"/_next/static/chunks/bc166ea53d390db7.js\",\"async\":true,\"nonce\":\"$undefined\"}]\ne:[\"$\",\"$L30\",null,{\"children\":[\"$\",\"$31\",null,{\"name\":\"Next.MetadataOutlet\",\"children\":\"$@32\"}]}]\nf:[\"$\",\"$1\",\"h\",{\"children\":[null,[\"$\",\"$L33\",null,{\"children\":\"$L34\"}],[\"$\",\"div\",null,{\"hidden\":true,\"children\":[\"$\",\"$L35\",null,{\"children\":[\"$\",\"$31\",null,{\"name\":\"Next.Metadata\",\"children\":\"$L36\"}]}]}],[\"$\",\"meta\",null,{\"name\":\"next-size-adjust\",\"content\":\"\"}]]}]\n"])</script><script>self.__next_f.push([1,"12:[\"$\",\"$L11\",null,{\"latex\":\"K\",\"className\":\"mt-10\"}]\n13:[\"$\",\"$L11\",null,{\"latex\":\"y_{K-1}\",\"className\":\"mt-10\"}]\n14:[\"$\",\"$L11\",null,{\"latex\":\"y_i^{(j)}\",\"className\":\"mt-10\"}]\n15:[\"$\",\"$L11\",null,{\"latex\":\"j\",\"className\":\"mt-10\"}]\n16:[\"$\",\"$L11\",null,{\"latex\":\"1\\\\leq i \\\\leq K-1\",\"className\":\"mt-10\"}]\n17:[\"$\",\"$L11\",null,{\"latex\":\"j\",\"className\":\"mt-10\"}]\n18:[\"$\",\"$L11\",null,{\"latex\":\"\\\\frac{\\\\partial \\\\ell}{\\\\partial y_i}\",\"displayMode\":true,\"className\":\"mt-10\"}]\n19:[\"$\",\"$L11\",null,{\"latex\":\"f\",\"className\":\"mt-10\"}]\n1a:[\"$\",\"$L11\",null,{\"latex\":\"L_i\",\"className\":\"mt-10\"}]\n1b:[\"$\",\"$L11\",null,{\"latex\":\"\\\\frac{\\\\partial \\\\ell}{\\\\partial W_i} = f\\\\left(y_i^{(j)},\\\\, \\\\frac{\\\\partial \\\\ell}{\\\\partial y_i}, L_i \\\\right) \\\\quad (\\\\text{weight gradient})\",\"displayMode\":true,\"className\":\"mt-10\"}]\n1c:[\"$\",\"$L11\",null,{\"latex\":\"\\\\frac{\\\\partial \\\\ell}{\\\\partial W_i} = \\\\left[\\\\frac{\\\\partial \\\\ell}{\\\\partial W_i^{(1)}}\\\\,\\\\middle|\\\\quad\\\\dots\\\\quad \\\\middle|\\\\, \\\\frac{\\\\partial \\\\ell}{\\\\partial W_i^{(N)}} \\\\right]\",\"displayMode\":true,\"className\":\"mt-10\"}]\n1d:[\"$\",\"span\",null,{\"className\":\"font-semibold\",\"children\":\"ReduceScatter\"}]\n1e:[\"$\",\"$L11\",null,{\"latex\":\"\\\\sum_{m=1}^N \\\\frac{\\\\partial \\\\ell}{\\\\partial W_i^{(j)}}\\\\quad (\\\\text{device}\\\\, j)\",\"displayMode\":true,\"className\":\"mt-10\"}]\n1f:[\"$\",\"$L11\",null,{\"latex\":\"N^{-1}\",\"className\":\"mt-10\"}]\n20:[\"$\",\"$L11\",null,{\"latex\":\"W_i^{(j)}\",\"className\":\"mt-10\"}]\n21:[\"$\",\"$L11\",null,{\"latex\":\"W_i^{(j)}\",\"className\":\"mt-10\"}]\n22:[\"$\",\"$L11\",null,{\"latex\":\"W_i^{(j)}\",\"className\":\"mt-10\"}]\n23:[\"$\",\"$L11\",null,{\"latex\":\"j\",\"className\":\"mt-10\"}]\n24:[\"$\",\"$L11\",null,{\"latex\":\"g\",\"className\":\"mt-10\"}]\n25:[\"$\",\"$L11\",null,{\"latex\":\"L_i\",\"className\":\"mt-10\"}]\n26:[\"$\",\"$L11\",null,{\"latex\":\"W_i\",\"className\":\"mt-10\"}]\n27:[\"$\",\"$L11\",null,{\"latex\":\"i\",\"className\":\"mt-10\"}]\n28:[\"$\",\"$L11\",null,{\"latex\":\"\\\\partial\\\\ell / \\\\partial y_i\",\"className\":\"mt-10\"}]\n29:[\"$\",\"$L11\",null,{\"latex\":\"\\\\frac{\\\\partial \\\\ell}{\\\\partial y_{i-1}} = g\\\\left(\\\\frac{\\\\partial\\\\ell}{\\\\partial y_i}, \\\\, W_i,\\\\, L_i\\\\right)\\\\quad (\\\\text{activation gradient})\",\"displayMode\":true,\"className\":\"mt-10\"}]\n2a:[\"$\",\"$L11\",null,{\"latex\":\"i\",\"className\":\"mt-10\"}]\n2b:[\"$\",\"$L11\",null,{\"latex\":\"i-1\",\"className\":\"mt-10\"}]\n2c:[\"$\",\"$L11\",null,{\"latex\":\"W_i\",\"className\":\"mt-10\"}]\n2d:[\"$\",\"$L11\",null,{\"latex\":\"W_i = \\\\textbf{AllGather}\\\\left\\\\{W_i^{(j)}: 1\\\\leq j \\\\leq N\\\\right\\\\}\",\"displayMode\":true,\"className\":\"mt-10\"}]\n2e:[\"$\",\"$L11\",null,{\"latex\":\"\\\\textbf{delete}\\\\left\\\\{W_i^{(k)}\\\\in W_i: j\\\\neq k\\\\right\\\\}\\\\quad (\\\\text{device}\\\\,j)\",\"displayMode\":true,\"className\":\"mt-10\"}]\n"])</script><script>self.__next_f.push([1,"34:[[\"$\",\"meta\",\"0\",{\"charSet\":\"utf-8\"}],[\"$\",\"meta\",\"1\",{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"}]]\n"])</script><script>self.__next_f.push([1,"37:I[87718,[\"/_next/static/chunks/988ea292de4c4c73.js\",\"/_next/static/chunks/7a959126392b4956.js\"],\"IconMark\"]\n32:null\n36:[[\"$\",\"title\",\"0\",{\"children\":\"Claire Zhao Blog\"}],[\"$\",\"meta\",\"1\",{\"name\":\"description\",\"content\":\"Claire Zhao's Blog on AI and Math\"}],[\"$\",\"link\",\"2\",{\"rel\":\"icon\",\"href\":\"/favicon.ico?favicon.e10ff5c7.ico\",\"sizes\":\"1176x1032\",\"type\":\"image/x-icon\"}],[\"$\",\"$L37\",\"3\",{}]]\n"])</script></body></html>