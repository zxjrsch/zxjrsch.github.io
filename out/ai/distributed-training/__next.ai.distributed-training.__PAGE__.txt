1:"$Sreact.fragment"
2:I[1565,["/_next/static/chunks/3020cc836eb789f8.js","/_next/static/chunks/e5d291186d0cbb54.js","/_next/static/chunks/bc166ea53d390db7.js"],"default"]
3:I[6366,["/_next/static/chunks/3020cc836eb789f8.js","/_next/static/chunks/e5d291186d0cbb54.js","/_next/static/chunks/bc166ea53d390db7.js"],"default"]
5:I[96045,["/_next/static/chunks/3020cc836eb789f8.js","/_next/static/chunks/e5d291186d0cbb54.js","/_next/static/chunks/bc166ea53d390db7.js"],"default"]
2e:I[56691,["/_next/static/chunks/3020cc836eb789f8.js","/_next/static/chunks/e5d291186d0cbb54.js","/_next/static/chunks/bc166ea53d390db7.js"],"default"]
2f:I[47259,["/_next/static/chunks/988ea292de4c4c73.js","/_next/static/chunks/7a959126392b4956.js"],"OutletBoundary"]
30:"$Sreact.suspense"
4:T501,Neural network weights is the first pieces of data that needs to be stored for the duration of training, it is used during forward pass to compute activation, and it is used during backwards pass to compute activation gradients. The second piece of data which require storage are the activation of each layers, since these are used to compute the  gradient of weights in the layer to which the activations are the inputs during forward pass, as we have already seen. Activation can be released whenever the weight gradients they are associated with are computed. The third piece of data that is stored are activation gradients. They are used to compute gradients during backpropagation through the next layer (or operation), and can be released after computing activation and weight gradients in the next layer (or operation). The fourth piece of data are weight gradients, with a lifetime from produced until the corresponding weights are updated. The fifth type of data are associated with the optimization algorithm which updates the weight using the gradients. In the Adam optimizer, we need to keep track of the exponential moving average of the weight and the square of each weight. These moving averages are ususally called optimizer states, and persist throughout training.0:{"buildId":"3WqXp_18PFG2QAibL4Ptl","rsc":["$","$1","c",{"children":[["$","div",null,{"className":"flex flex-col justify-center min-h-screen","children":[["$","div",null,{"className":"flex flex-row justify-center pt-15","children":["$","$L2",null,{}]}],["$","div",null,{"className":"grow flex justify-center w-full pt-10 md:pt-15 px-3","children":["$","div",null,{"className":"flex flex-col w-full max-w-full md:max-w-2xl lg:max-w-3xl","children":[["$","div",null,{"className":"text-3xl font-bold flex justify-center","children":"6D Parallelism for Distributed Training"}],["$","div",null,{"className":"text-sm flex justify-center pt-5","children":null}],["$","div",null,{"className":"","children":[["$","div","0",{"children":["$undefined",["$","div",null,{"className":"indent-10 md:mt-10 grow text-lg font-medium text-base text-justify","children":[["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":["Matrix multiplication is a fundamental operator in neural networks, and in the previous ",["$","$L3",null,{"text":"blog","url":"/ai/distributed-training"}]," we have fully elucidated the differentiation of the loss through such an operator in full generality, and we have applied this to the attention operator, a compound operator consisting of a series of matrix mulitiplications. Let us assemble a clear view of the process of training a neural network. In particular let us examine the data being stored and their persistence."]}],["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":"$4"}],["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":"The effective management of the persistence and distribution (across GPUS and CPUs) is a core systems optimization problem."}]]}]]}],["$","div","1",{"children":[["$","div",null,{"className":" pt-20 font-bold text-2xl","id":"section-2","children":"Distributed Data Parallel"}],["$","div",null,{"className":"indent-10 md:mt-10 grow text-lg font-medium text-base text-justify","children":["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":["We replicate a set of model weights identically across ",["$","$L5",null,{"latex":"N","className":"mt-10"}]," GPUs. Each GPU holds a distinct collection of training data. Each GPU passes forward with the data to compute the loss, and performs backward pass to compute the gradient. The gradient is ","$L6"," over ","$L7"," parallel agents, and scaled by ","$L8"," to obtain the average gradient. Each local parallel agent now holds identical copies of the global gradient. This gradient produces identical optimizer states across ","$L9"," parallel agents. The optimizer have identical gradients, identical optimizer states, produces identical updated model weights across ","$La"," GPUs. The procedure is repeated."]}]}]]}],"$Lb"]}]]}]}],"$Lc"]}],["$Ld","$Le","$Lf"],"$L10"]}],"loading":null,"isPartial":false}
6:["$","span",null,{"className":"font-semibold","children":"all reduced"}]
7:["$","$L5",null,{"latex":"N","className":"mt-10"}]
8:["$","$L5",null,{"latex":"N^{-1}","className":"mt-10"}]
9:["$","$L5",null,{"latex":"N","className":"mt-10"}]
a:["$","$L5",null,{"latex":"N","className":"mt-10"}]
b:["$","div","2",{"children":[["$","div",null,{"className":" pt-20 font-bold text-2xl","id":"section-2","children":"Fully Sharded Data Parallel"}],["$","div",null,{"className":"indent-10 md:mt-10 grow text-lg font-medium text-base text-justify","children":[["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":["Suppose a neural network consists of ",["$","$L5",null,{"latex":"K","className":"mt-10"}]," layers ",["$","$L5",null,{"latex":"\\{L_i\\}_{i=1}^K","className":"mt-10"}]," whereby each layer is a function with suitable domain and range. The neural network evaluated on ",["$","$L5",null,{"latex":"x","className":"mt-10"}]," leading to loss ",["$","$L5",null,{"latex":"\\ell(x)","className":"mt-10"}],", is defined by ",["$","$L5",null,{"latex":"\\ell (x) = \\left(L_K\\circ \\dots \\circ L_1 \\right)(x)","displayMode":true,"className":"mt-10"}]," Let us introduce the notation that ",["$","$L5",null,{"latex":"L_i","className":"mt-10"}]," is a function parameterized by weight ",["$","$L5",null,{"latex":"W_i","className":"mt-10"}]," and takes as input the previous layer's activation ",["$","$L5",null,{"latex":"y_{i-1} = \\left(L_{i-1}\\circ \\dots \\circ L_1 \\right)(x)","className":"mt-10"}],"."]}],["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":["Given dataset ",["$","$L5",null,{"latex":"\\mathcal{D}","className":"mt-10"}],", weight matrices ",["$","$L5",null,{"latex":"\\{W_i\\}_{i=1}^K","className":"mt-10"}]," and ",["$","$L5",null,{"latex":"N","className":"mt-10"}]," parallel agents (GPU, TPU etc) we partition the dataset into ",["$","$L5",null,{"latex":"N","className":"mt-10"}]," pariwise disjoint subsets ",["$","$L5",null,{"latex":"\\mathcal{D} = \\mathcal{D}^{(1)}\\,\\cup \\dots \\cup \\mathcal{D}^{(N)}","className":"mt-10"}]," and partition each weight matrix into N slices, for example ",["$","$L5",null,{"latex":"W_i = [W_i^{(1)}| \\dots | W_i^{(N)}]","displayMode":true,"className":"mt-10"}]," To the ",["$","$L5",null,{"latex":"j","className":"mt-10"}],"-th parallel agent we send ",["$","$L5",null,{"latex":"\\left(\\mathcal{D}^{(j)}, \\, W_1^{(j)}, \\dots, W_K^{(j)}\\right)","className":"mt-10"}]]}],["$","div",null,{"className":"indent-10 md:mt-5 grow text-lg font-medium text-base text-justify","children":["To describe one step in training, each of the parallel agents ",["$","$L5",null,{"latex":"1\\leq j \\leq N","className":"mt-10"}]," selects a training data ",["$","$L5",null,{"latex":"x^{(j)}\\in \\mathcal{D}^{(j)}","className":"mt-10"}]," and puts ",["$","$L5",null,{"latex":"y_0^{(j)}=x^{(j)}","className":"mt-10"}],". For ",["$","$L5",null,{"latex":"1\\leq i \\leq K","className":"mt-10"}]," suppose the activation ",["$","$L5",null,{"latex":"y_{i-1}^{(j)}","className":"mt-10"}]," has been computed and the forward pass is ready to advance through layer ",["$","$L5",null,{"latex":"L_i","className":"mt-10"}]," on parallel agent ",["$","$L5",null,{"latex":"j","className":"mt-10"}]," we call ",["$","$L5",null,{"latex":"W_i = \\textbf{AllGather}\\left\\{W_i^{(j)}: 1\\leq j \\leq N\\right\\}","displayMode":true,"className":"mt-10"}]," and compute ",["$","$L5",null,{"latex":"y^{(j)}_i=L_i(y^{(j)}_{i-1})","className":"mt-10"}]," and immediately free the memory on device ",["$","$L5",null,{"latex":"j","className":"mt-10"}]," of the weight shards ",["$","$L5",null,{"latex":"\\textbf{delete}\\left\\{W_i^{(k)}\\in W_i: j\\neq k\\right\\}\\quad (\\text{device}\\,j)","displayMode":true,"className":"mt-10"}]," and store the layer-",["$","$L5",null,{"latex":"i","className":"mt-10"}]," activation for weight gradient calculation through ",["$","$L5",null,{"latex":"L_i","className":"mt-10"}]," during backward pass ",["$","$L5",null,{"latex":"\\textbf{store}\\,\\, y_i^{(j)}\\quad(\\text{device } j)","displayMode":true,"className":"mt-10"}]," Let us turn to backwards pass. In our notation ",["$","$L5",null,{"latex":"L_K","className":"mt-10"}]," computes the loss function and this layer has no weights, so as backwards we get ",["$","$L5",null,{"latex":"\\frac{\\partial \\ell}{\\partial y_{K-1}}","displayMode":true,"className":"mt-10"}],"just as reminder ",["$","$L5",null,{"latex":"y_{K-1}","className":"mt-10"}]," is the output of layer ",["$","$L5",null,{"latex":"K-1","className":"mt-10"}],", which is the input to layer ","$L11",". We will treat ","$L12"," as a variable, whereas the actual activation has a superscript ","$L13"," to identify the device ","$L14",". For each ","$L15"," supposed that device ","$L16"," computed its local activation gradient ","$L17"," have computed. Then the local weight gradient can be computed as a function ","$L18"," of the map ","$L19",", the activation gradient, and the local activation ","$L1a"," Since weights are kept in shards across the parallel agents, we need to partition the weight gradient too ","$L1b"," we will use ","$L1c"," to provide each parallel agent with the average gradient corresponding to the weight shard it owns, namely it receives ","$L1d"," scaling by ","$L1e"," this is the average gradient for its local weight shard ","$L1f",". The local Adam optimizer stores exponential moving averages of ","$L20"," and the component-wise square of ","$L21",". Thus optimizer states are sharded as well. Finally each parallel agent ","$L22"," needs to compute its local activation gradient as a function ","$L23"," of the function ","$L24"," (that we will differentiate via the chain rule) and the weight ","$L25"," of layer ","$L26"," together with ","$L27"," namely ","$L28"," Computing this allows  backpropagation to advance from layer ","$L29"," to layer ","$L2a",". To do this we need to AllGather the weight ","$L2b"," on each of the parallel agents  ","$L2c"," After computing the activaiton gradient ","$L2d"]}]]}]]}]
c:["$","$L2e",null,{}]
d:["$","script","script-0",{"src":"/_next/static/chunks/3020cc836eb789f8.js","async":true}]
e:["$","script","script-1",{"src":"/_next/static/chunks/e5d291186d0cbb54.js","async":true}]
f:["$","script","script-2",{"src":"/_next/static/chunks/bc166ea53d390db7.js","async":true}]
10:["$","$L2f",null,{"children":["$","$30",null,{"name":"Next.MetadataOutlet","children":"$@31"}]}]
11:["$","$L5",null,{"latex":"K","className":"mt-10"}]
12:["$","$L5",null,{"latex":"y_{K-1}","className":"mt-10"}]
13:["$","$L5",null,{"latex":"y_i^{(j)}","className":"mt-10"}]
14:["$","$L5",null,{"latex":"j","className":"mt-10"}]
15:["$","$L5",null,{"latex":"1\\leq i \\leq K-1","className":"mt-10"}]
16:["$","$L5",null,{"latex":"j","className":"mt-10"}]
17:["$","$L5",null,{"latex":"\\frac{\\partial \\ell}{\\partial y_i}","displayMode":true,"className":"mt-10"}]
18:["$","$L5",null,{"latex":"f","className":"mt-10"}]
19:["$","$L5",null,{"latex":"L_i","className":"mt-10"}]
1a:["$","$L5",null,{"latex":"\\frac{\\partial \\ell}{\\partial W_i} = f\\left(y_i^{(j)},\\, \\frac{\\partial \\ell}{\\partial y_i}, L_i \\right) \\quad (\\text{weight gradient})","displayMode":true,"className":"mt-10"}]
1b:["$","$L5",null,{"latex":"\\frac{\\partial \\ell}{\\partial W_i} = \\left[\\frac{\\partial \\ell}{\\partial W_i^{(1)}}\\,\\middle|\\quad\\dots\\quad \\middle|\\, \\frac{\\partial \\ell}{\\partial W_i^{(N)}} \\right]","displayMode":true,"className":"mt-10"}]
1c:["$","span",null,{"className":"font-semibold","children":"ReduceScatter"}]
1d:["$","$L5",null,{"latex":"\\sum_{m=1}^N \\frac{\\partial \\ell}{\\partial W_i^{(j)}}\\quad (\\text{device}\\, j)","displayMode":true,"className":"mt-10"}]
1e:["$","$L5",null,{"latex":"N^{-1}","className":"mt-10"}]
1f:["$","$L5",null,{"latex":"W_i^{(j)}","className":"mt-10"}]
20:["$","$L5",null,{"latex":"W_i^{(j)}","className":"mt-10"}]
21:["$","$L5",null,{"latex":"W_i^{(j)}","className":"mt-10"}]
22:["$","$L5",null,{"latex":"j","className":"mt-10"}]
23:["$","$L5",null,{"latex":"g","className":"mt-10"}]
24:["$","$L5",null,{"latex":"L_i","className":"mt-10"}]
25:["$","$L5",null,{"latex":"W_i","className":"mt-10"}]
26:["$","$L5",null,{"latex":"i","className":"mt-10"}]
27:["$","$L5",null,{"latex":"\\partial\\ell / \\partial y_i","className":"mt-10"}]
28:["$","$L5",null,{"latex":"\\frac{\\partial \\ell}{\\partial y_{i-1}} = g\\left(\\frac{\\partial\\ell}{\\partial y_i}, \\, W_i,\\, L_i\\right)\\quad (\\text{activation gradient})","displayMode":true,"className":"mt-10"}]
29:["$","$L5",null,{"latex":"i","className":"mt-10"}]
2a:["$","$L5",null,{"latex":"i-1","className":"mt-10"}]
2b:["$","$L5",null,{"latex":"W_i","className":"mt-10"}]
2c:["$","$L5",null,{"latex":"W_i = \\textbf{AllGather}\\left\\{W_i^{(j)}: 1\\leq j \\leq N\\right\\}","displayMode":true,"className":"mt-10"}]
2d:["$","$L5",null,{"latex":"\\textbf{delete}\\left\\{W_i^{(k)}\\in W_i: j\\neq k\\right\\}\\quad (\\text{device}\\,j)","displayMode":true,"className":"mt-10"}]
31:null
